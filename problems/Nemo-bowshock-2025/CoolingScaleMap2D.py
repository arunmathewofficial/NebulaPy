"""
Multiple Ion 2D Cooling Function Map
Description: Generate cooling function map from
2D PION simulation silo files
Author: Arun Mathew
Date: 20 Nov 2024
"""

import numpy as np
import os
import time
from NebulaPy.tools import util
from NebulaPy.tools import constants as const
import NebulaPy.src as nebula
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.ticker import MultipleLocator, ScalarFormatter
import warnings
import h5py
# Suppress specific warnings
warnings.filterwarnings("ignore", category=RuntimeWarning, message="divide by zero encountered in log10")

SEC_TO_YEAR = 1 / 31_557_600  # seconds to years
CM_TO_PC = 1 / 3.085677581e18


def generate_velocity_field(pion, silo_instant, wind_speed, stellar_speed):

    print(f" generating an approximate velocity feild with v_w = {wind_speed} km/s and v_* = {stellar_speed} km/s")

    # Extract necessary parameters from the simulation
    density = pion.get_parameter('Density', silo_instant)
    grid_mask = pion.get_parameter('NG_Mask', silo_instant)
    velocity_field = [np.full(arr.shape, stellar_speed * 1e+5) for arr in density]
    wind_tracer = pion.get_parameter('Tr000_WIND', silo_instant)

    for level in range(N_grid_level):
        velocity_field[level][wind_tracer[level] >= 0.5] = wind_speed * 1e+5
        velocity_field[level] = velocity_field[level] * grid_mask[level]

    return velocity_field

def ntot(silo_instant):
    # todo: move this method to pion class
    '''
    Calculate total number density including all ions
    :param silo_instant:
    :return:
    '''
    n_tot = pion.get_ne()
    # one has to get the ion list from pion class
    for ion in ion_list:
        n_ion = pion.get_ion_number_density(ion, silo_instant)
        for level in range(N_grid_level):
            n_tot += n_ion[level]
    return n_tot

# MIMIR (Set up paths and filenames)
#output_dir = '/mnt/massive-stars/data/arun_simulations/Nemo_BowShock/high-res/cooling-map'  # Output image directory
#silo_dir = '/mnt/massive-stars/data/arun_simulations/Nemo_BowShock/high-res/silo'  # Directory containing silo files
#filebase = 'Ostar_mhd-nemo-dep_d2n0384l3'  # Base name of the silo files
#start_time = 190
#finish_time = None
#out_frequency = None

#Razer Blade (Set up paths and filenames)
output_dir = '/home/tony/Desktop/multi-ion-bowshock/sim-output/coolscales'  # Output image directory
silo_dir = '/home/tony/Desktop/multi-ion-bowshock/high-res-silo-200kyr'  # Directory containing silo files
filebase = 'Ostar_mhd-nemo-dep_d2n0384l3'  # Base name of the silo files
start_time = None
finish_time = None
out_frequency = None
wind_speed = 2000 # km/s
stellar_speed = 30 # km/s

ion_list = [
    'H', 'H1+',
    'He', 'He1+', 'He2+',
    'C', 'C1+', 'C2+', 'C3+', 'C4+', 'C5+', 'C6+',
    'N', 'N1+', 'N2+', 'N3+', 'N4+', 'N5+', 'N6+', 'N7+',
    'O', 'O1+', 'O2+', 'O3+', 'O4+', 'O5+', 'O6+', 'O7+', 'O8+',
    'Ne1+', 'Ne2+', 'Ne3+', 'Ne4+', 'Ne5+', 'Ne6+', 'Ne7+', 'Ne8+', 'Ne9+', 'Ne10+',
    'Si1+', 'Si2+', 'Si3+', 'Si4+', 'Si5+', 'Si6+', 'Si7+', 'Si8+', 'Si9+', 'Si10+',
    'Si11+', 'Si12+', 'Si13+', 'Si14+',
    'S', 'S1+', 'S2+', 'S3+', 'S4+', 'S5+', 'S6+', 'S7+', 'S8+', 'S9+', 'S10+', 'S11+',
    'S12+', 'S13+', 'S14+', 'S15+', 'S16+',
    'Fe4+', 'Fe5+', 'Fe6+', 'Fe7+', 'Fe8+', 'Fe9+', 'Fe10+', 'Fe11+', 'Fe12+', 'Fe13+',
    'Fe14+', 'Fe15+', 'Fe16+', 'Fe17+', 'Fe18+', 'Fe19+', 'Fe20+', 'Fe21+', 'Fe22+',
    'Fe23+', 'Fe24+', 'Fe25+', 'Fe26+'
]

# Batch the silo files according to the time instant
batched_silos = util.batch_silos(
    silo_dir,
    filebase,
    start_time=start_time,
    finish_time=finish_time,
    time_unit='kyr',
    out_frequency=out_frequency
)

# Initialize the Pion class from NebulaPy, which handles the simulation data
pion = nebula.pion(batched_silos, verbose=True)

# Calculates and stores geometric grid parameters.
# For example, in a spherical geometry, it extracts radius and shell volumes
# from the first silo file in the batch and saves them into a geometry container.
pion.load_geometry(scale='pc')
N_grid_level = pion.geometry_container['Nlevel']
mesh_edges_min = pion.geometry_container['edges_min']
mesh_edges_max = pion.geometry_container['edges_max']

# h5 header and metadata
heading = f"Generated by {util.nebula_version()}"
metadata = {"minimum_mesh_edges": mesh_edges_min,
            "maximum_mesh_edges": mesh_edges_max,
            'Nlevels': N_grid_level}

# Extract all chemistry information from the silo files into a chemistry container
# This uses the first time instant's silo file to initialize
pion.load_chemistry()

Nstep = len(batched_silos)
runtime = 0.0

# Loop over each time instant in the batched silo files
for step, silo_instant in enumerate(batched_silos):

    silo_instant_start_time = time.time()  # Record the start time
    print(f" ---------------------------")
    # Print the current simulation time instant
    sim_time = pion.get_simulation_time(silo_instant, time_unit='kyr')
    print(f" step: {step}/{Nstep} | simulation time: {sim_time:.6e}")

    # h5 metadata
    metadata['step'] = step
    metadata['simulation-time'] = sim_time.value
    metadata['time-unit'] = str(sim_time.unit)

    # Extract necessary physical parameters for the current time instant
    density = pion.get_parameter('Density', silo_instant)  # Retrieve density
    temperature = pion.get_parameter('Temperature', silo_instant)  # Retrieve temperature
    grid_mask = pion.get_parameter('NG_Mask', silo_instant)
    # Identify the shape of each density array to ensure compatibility with other parameters.
    shape_list = [arr.shape for arr in density]

    total_cooling_function = [np.zeros(shape) for shape in shape_list]
    total_cooling_timescale = [np.zeros(shape) for shape in shape_list]
    total_cooling_lengthscale = [np.zeros(shape) for shape in shape_list]

    # Retrieve the electron number density
    ne = pion.get_ne(silo_instant)
    # Retrieve the total number density from the particular instant from the chemistry container
    ntot = ntot(silo_instant)
    
    for index, ion in enumerate(ion_list):

        util.nebula_info(f"computing {ion} cooling time-scale map")
        cooling = nebula.cooling(pion_ion=ion, verbose=True)
        ion_name = ion.replace('+', 'p')
        ion_output_dir = os.path.join(output_dir, ion_name)
        os.makedirs(ion_output_dir, exist_ok=True)

        # calculating normalization factor
        mass_density_ism = 1.0E-24
        mass_H = const.mass['H']
        norm = (mass_H / mass_density_ism) ** 2.0

        data_title = f"Bow-Shock cooling time-scale for ion the {ion}"

        h5_filename = f"{filebase}_coolmap_{ion_name}_{str(step).zfill(4)}.h5"
        h5_file = os.path.join(ion_output_dir, h5_filename)

        # Retrieve the ion number density
        n_ion = pion.get_ion_number_density(ion, silo_instant)

        print(f" generating {ion} cooling timescale map for each grid level(s)")
        # Initialize arrays for ion cooling rate
        ion_cooling_rate = [np.zeros(shape) for shape in shape_list]
        for level in range(N_grid_level):
            level_cooling_rate_map = cooling.generate_cooling_rate_map(
                temperature=temperature[level], ne=ne[level])
            ion_cooling_rate[level] = level_cooling_rate_map

        # Initialize arrays for ion cooling time scale map
        ion_cooling_timescale_map = [np.zeros(shape) for shape in shape_list]

        for level in range(N_grid_level):
            ion_cooling_timescale_map[level] = 3.0 * const.kB * temperature[level] * SEC_TO_YEAR / (2.0 * ne[level] * n_ion[level] * ion_cooling_rate[level])
            total_cooling_function[level] += n_ion[level] * ion_cooling_rate[level]

        # saving data to h5 file ########################################################
        print(f" saving cooling timescale map data to: {h5_filename}")
        with h5py.File(h5_file, "w") as file:
            # Add heading and title
            file.attrs['head'] = heading
            file.attrs['title'] = data_title
            # Save metadata
            meta = file.create_group("metadata")
            for key, value in metadata.items():
                if isinstance(value, list):
                    meta.create_dataset(key, data=value)
                else:
                    meta.attrs[key] = value
            # Save cooling function map
            file.create_dataset("cooling_timescale_map", data=np.array(ion_cooling_timescale_map, dtype=np.float32))
        # end of saving data to h5 file #################################################

        # generating image
        fig, ax = plt.subplots(figsize=(8, 6))

        ax.text(0.05, 0.9, 'time = %5.2f kyr' % sim_time.value, transform=ax.transAxes,
                fontsize=12, color='white')
        ax.set_xlim(mesh_edges_min[0][0].value, mesh_edges_max[0][0].value)
        ax.set_ylim(mesh_edges_min[0][1].value, mesh_edges_max[0][1].value)

        # Assuming parameter_data, dims_min_1, dims_max_1, and cmap_value are defined
        # Assuming ax is already defined
        for level in range(N_grid_level):
            plot_data = np.log10(ion_cooling_timescale_map[level])
            extents = [mesh_edges_min[level][0].value, mesh_edges_max[level][0].value,
                       mesh_edges_min[level][1].value, mesh_edges_max[level][1].value]

            image = ax.imshow(plot_data, interpolation='nearest', cmap='inferno',
                              extent=extents, origin='lower',
                              vmin=0, vmax=6
                              )

        # Create divider for existing axes instance
        divider = make_axes_locatable(ax)
        # Append axes to the right of ax1
        cax = divider.append_axes("right", size="5%", pad=0.05)

        # Add colorbar with appropriate ticks
        colorbar = plt.colorbar(image, cax=cax, ticks=MultipleLocator(1))

        # Set the formatter for the colorbar
        colorbar.ax.yaxis.set_major_formatter(ScalarFormatter())
        colorbar.ax.yaxis.get_major_formatter().set_scientific(False)  # Disable scientific notation
        colorbar.ax.yaxis.get_major_formatter().set_useOffset(False)  # Disable offset

        # Update the ticks for the colorbar
        colorbar.update_ticks()

        ax.set_xlabel('z (pc)', fontsize=12)
        ax.set_ylabel('R (pc)', fontsize=12)

        # Correctly add text to the plot

        ax.text(0.65, 0.9, f"${ion}~\\tau_{{\\mathrm{{cool}}}}(\\mathrm{{yr}})$",
                transform=ax.transAxes, fontsize=12, color='black')
        ax.tick_params(axis='both', which='major', labelsize=13)

        # fig.subplots_adjust(wspace=0, hspace=0)  # Remove the whitespace between the images
        filename = f"{filebase}_cooltime_{ion_name}_{str(step).zfill(4)}.png"
        filepath = os.path.join(ion_output_dir, filename)
        plt.savefig(filepath, bbox_inches="tight", dpi=300)
        plt.close(fig)
        print(f" saving cooling function map image to: {filename}")

    # total cooling time scale and cooling lenghtscale
    util.nebula_info("generating total cooling time-scale and length-scale maps")
    print(" calculating total cooling time-scale")
    # get total number density including all ions ntot
    for level in range(N_grid_level):
        total_cooling_timescale[level] = 3.0 * const.kB * ntot[level] * temperature[level] / (2.0 * ne[level] * total_cooling_function[level])
        # Find min and max

    # Convert the list of arrays into a single array to find global min/max
    all_timescales = np.concatenate(total_cooling_timescale)
    min_timescale = np.min(all_timescales)
    max_timescale = np.max(all_timescales)
    print(f" minimum cooling timescale from the snapshot: {min_timescale * SEC_TO_YEAR:.5e} yr")
    print(f" maximum cooling timescale from the snapshot: {max_timescale * SEC_TO_YEAR:.5e} yr")

    print(" calculating cooling length-scale map")
    # generate flow velocity (this is an approximate method)
    flow_velocity = generate_velocity_field(pion, silo_instant, wind_speed, stellar_speed)
    for level in range(N_grid_level):
        total_cooling_lengthscale[level] = flow_velocity[level] * total_cooling_timescale[level]

    # generating cooling time scale map image
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.text(0.05, 0.9, 'time = %5.2f kyr' % sim_time.value, transform=ax.transAxes,
            fontsize=12, color='white')
    ax.set_xlim(mesh_edges_min[0][0].value, mesh_edges_max[0][0].value)
    ax.set_ylim(mesh_edges_min[0][1].value, mesh_edges_max[0][1].value)
    # Assuming parameter_data, dims_min_1, dims_max_1, and cmap_value are defined
    # Assuming ax is already defined
    for level in range(N_grid_level):
        plot_data = np.log10(total_cooling_timescale[level] * SEC_TO_YEAR)
        extents = [mesh_edges_min[level][0].value, mesh_edges_max[level][0].value,
                   mesh_edges_min[level][1].value, mesh_edges_max[level][1].value]
        image = ax.imshow(plot_data, interpolation='nearest', cmap='inferno',
                          extent=extents, origin='lower',
                          vmin=0, vmax=6
                          )
    # Create divider for existing axes instance
    divider = make_axes_locatable(ax)
    # Append axes to the right of ax1
    cax = divider.append_axes("right", size="5%", pad=0.05)
    # Add colorbar with appropriate ticks
    colorbar = plt.colorbar(image, cax=cax, ticks=MultipleLocator(1))
    # Set the formatter for the colorbar
    colorbar.ax.yaxis.set_major_formatter(ScalarFormatter())
    colorbar.ax.yaxis.get_major_formatter().set_scientific(False)  # Disable scientific notation
    colorbar.ax.yaxis.get_major_formatter().set_useOffset(False)  # Disable offset
    # Update the ticks for the colorbar
    colorbar.update_ticks()
    ax.set_xlabel('z (pc)', fontsize=12)
    ax.set_ylabel('R (pc)', fontsize=12)
    # Correctly add text to the plot
    ax.text(0.65, 0.9, f"$\\tau_{{\\mathrm{{cool}}}}(\\mathrm{{yr}})$",
            transform=ax.transAxes, fontsize=12, color='white')
    ax.tick_params(axis='both', which='major', labelsize=13)
    # ax.axes.get_xaxis().set_visible(False)  # Remove the x-axis

    # fig.subplots_adjust(wspace=0, hspace=0)  # Remove the whitespace between the images
    timescale_filename = f"{filebase}_total_cooling_timescale_{str(step).zfill(4)}.png"
    filepath = os.path.join(output_dir, timescale_filename)
    plt.savefig(filepath, bbox_inches="tight", dpi=300)
    plt.close(fig)
    print(f" saving total cooling time-scale map to: {timescale_filename}")

    # generating cooling length scale map image
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.text(0.05, 0.9, 'time = %5.2f kyr' % sim_time.value, transform=ax.transAxes,
            fontsize=12, color='white')
    ax.set_xlim(mesh_edges_min[0][0].value, mesh_edges_max[0][0].value)
    ax.set_ylim(mesh_edges_min[0][1].value, mesh_edges_max[0][1].value)
    # Assuming parameter_data, dims_min_1, dims_max_1, and cmap_value are defined
    # Assuming ax is already defined
    for level in range(N_grid_level):
        plot_data = np.log10(total_cooling_lengthscale[level] * CM_TO_PC)
        extents = [mesh_edges_min[level][0].value, mesh_edges_max[level][0].value,
                   mesh_edges_min[level][1].value, mesh_edges_max[level][1].value]
        image = ax.imshow(plot_data, interpolation='nearest', cmap='inferno',
                          extent=extents, origin='lower',
                          #vmin=0, vmax=1
                          )
    # Create divider for existing axes instance
    divider = make_axes_locatable(ax)
    # Append axes to the right of ax1
    cax = divider.append_axes("right", size="5%", pad=0.05)
    # Add colorbar with appropriate ticks
    colorbar = plt.colorbar(image, cax=cax, ticks=MultipleLocator(1))
    # Set the formatter for the colorbar
    colorbar.ax.yaxis.set_major_formatter(ScalarFormatter())
    colorbar.ax.yaxis.get_major_formatter().set_scientific(False)  # Disable scientific notation
    colorbar.ax.yaxis.get_major_formatter().set_useOffset(False)  # Disable offset
    # Update the ticks for the colorbar
    colorbar.update_ticks()
    ax.set_xlabel('z (pc)', fontsize=12)
    ax.set_ylabel('R (pc)', fontsize=12)
    # Correctly add text to the plot
    ax.text(0.65, 0.9, f"$\\ell_{{\\mathrm{{cool}}}}(\\mathrm{{pc}})$",
            transform=ax.transAxes, fontsize=12, color='white')
    ax.tick_params(axis='both', which='major', labelsize=13)
    # ax.axes.get_xaxis().set_visible(False)  # Remove the x-axis

    # fig.subplots_adjust(wspace=0, hspace=0)  # Remove the whitespace between the images
    lengthscale_filename = f"{filebase}_total_cooling_lengthscale_{str(step).zfill(4)}.png"
    filepath = os.path.join(output_dir, lengthscale_filename)
    plt.savefig(filepath, bbox_inches="tight", dpi=300)
    plt.close(fig)
    print(f" saving total cooling length-scale map to: {lengthscale_filename}")

    silo_instant_finish_time = time.time()  # Record the finish time
    # Calculate the time spent on the current step
    dt = silo_instant_finish_time - silo_instant_start_time
    # Update the runtime with the time spent on the current step
    runtime += dt
    print(f" runtime: {runtime:.4e} s | dt: {dt:.4e} s")








